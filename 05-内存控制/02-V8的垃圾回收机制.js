/**
 * 1. V8 主要的垃圾回收算法
 * V8的垃圾回收策略主要基于 -> 分代式垃圾回收机制. 在自动垃圾回收的演变过程中, 人们发现没有一种垃圾回收算法
 * 能够胜任所有的场景. 因为在实际的应用中, 对象的生存周期长短不一, 不同的算法只能针对特定情况具有最好的效果. 为
 * 此, 统计学在垃圾回收算法的发展中产生较大的作用, 现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的
 * 分代, 然后分别对不同分代的内存施以更高效的算法
 * 
 * > V8 的内存分代
 * 在V8中, 主要将内存分为新生代和老生代两代.新生代中的对象为存活时间较短的对象, 老生代的对象为存活时间较长或常驻
 * 内存的对象. 
 * > 新生代的内存空间 +  老生代的内存空间
 * 
 * V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间. 前面我们提及到 --max-old-space-size 命令行参数
 * 可以用于设置老生代内存空间的最大值, --max-new-space-size 命令行参数则用于设置新生代内存空间的大小的. 比较
 * 遗憾的是, 这两个最大值需要在启动时就指定. 这意味着V8使用的内存没有办法根据使用情况自动扩充, 当内存分配过程中
 * 超过极限值时, 就会引起进程出错.
 * 
 * 前面提到过, 在默认设置下, 如果一直分配内存,在64位系统和32位系统下会分别只能使用约 1.4GB 和 约0.7GB的大小.这
 * 个限制可以从V8的源码中找到. 在下面的代码中, Page::kPageSize 的值为1MB, 可以看到, 老生代的设置在 64 为系统下
 * 为 1400MB, 在32位系统下为 700MB
 * 
 * 对于新生代内存, 它由两个 reserved_semispace_size_ 所构成, 后面将描述其原因. 按机器位数不同,reserved_semispace_size_
 * 在64位系统和32位系统上分别为16MB 和 8MB. 所以新生代内存的最大值在64位系统和32位系统上分别为32MB 和 16MB.
 */

/**
 * 2. Scavenge 算法
 * 在分代的基础上,新生代中的对象主要通过Scavenge算法进行垃圾回收. 在Scavenge的具体实现中, 主要采用了 Cheney算法, 该算法
 * 由 C.J.Cheney 与 1970年首次发表的ACM论文上.
 * 
 * Cheney 算法是一种采用复制的方式实现的垃圾回收算法. 它将堆内存一分为二, 每一部分空间称为 semispace. 在这两个 semispace
 * 空间中, 只有一个处于使用的, 另一个处于空闲状态.
 * 处于使用状态的 semispace 空间称为From空间, 处于闲置状态的空间称为To空间. 
 * 当我们分配对象时, 先是在From空间中进行分配. 当开始进行垃圾回收时, 会检查From空间中的存活对象, 这些存活对象将被复制到To空间中,
 * 而非存活对象占用的空间将会被释放. 完成复制后, From空间和To空间的角色发生兑换. 简而言之, 在垃圾回收的过程中, 就是通过将存活
 * 对象在两个 semispace 空间之间进行复制. 
 * 
 * Scavenge的缺点是只能使用堆内存中的一半, 这是由划分空间和复制机制所决定的. 但Scavenge由于只复制存活的对象, 并且对于生命周期
 * 短的场景存活对象只占少部分,所以它在时间效率上有优异的表现.
 * 
 * 由于Scavenge是典型的牺牲空间换取时间的算法,所以无法大规模地应用到所有的垃圾回收中. 但可以发现, Scavenge 非常适合应用在新
 * 生代中, 因为新生代中对象的生命周期较短, 恰恰适合这个算法.
 * 
 * V8 的堆内存示意图应当如下
 * -------------------------------------
 *   新生代内存空间     |    老生代内存空间
 *  semi   |  semi   |
 *  space  |  space   |
 *  (From) |  (To)    |
 * 
 * 当一个对象经过多次复制依然存活时, 它将会被认为是声明周期较长的对象. 这种较长声明周期的对象随后会被移动到老生代中, 采用新的算法进行
 * 管理. 对象从新生代中移动到老生代中的过程称为晋升.
 * 
 * 在单纯的 Scavenge 过程中, From空间中的存活对象会被复制到To空间中去, 然后对From空间和To空间进行角色对换(又称翻转). 但在分代式垃圾
 * 回收的前提下, From 空间中的存活对象在复制到To空间之前需要进行检查.  在一定条件下, 需要将存活周期长的对象移动到老生代中,也就是完成对象
 * 晋升.
 * 
 * 对象晋升的条件主要有两个: 
 * > 一个是对象是否经历过 Scavenge 回收;
 * > 一个是To空间的内存占用比超过限制;
 * 
 * 在默认情况下, V8 的对象分配主要集中的From空间中. 对对象从From空间中赋值到To空间时, 会检查它的内存地址来判断这个对象是否已经经历
 * 过一次 Scavenge 回收. 如果已经经历过了, 会将该对象从From空间复制到老生代空间中, 如果没有, 则复制到To空间中.这个晋升流程如下
 * 
 *   | semi space |
 *   |  (From)    |
 *        |
 *        |
 *        V
 *   | 经历过Scavenge |  --- 否  --->  |  semi space |
 *   |    回收?       |
 *        |
 *        是
 *        V
 *   | 老生代空间    |
 * 
 * 另一个判断条件是To空间的内存占用比. 当要从From空间复制一个对象到 To 空间时, 如果To空间已经使用了超过 25%, 
 * 则这个对象直接晋升到老生代空间中, 这个晋升的判断如下
 * 
 *   | semi space  |
 *   |   (From)    |
 *         |
 *         V
 *   | To空间已经   |
 *   | 使用了 25%?  |  -- 否  -->  |  semi space |
 *         |                      |    (To)     |
 *         是
 *         \
 *         V
 *   | 老生代空间    |
 * 
 * 设置25% 这个限制值的原因是当这次 Scavenge 回收完成后, 这个To空间将变成From空间, 接下来的内存分配将在这个
 * 空间中进行. 如果占比过高, 会影响后续的内存分配.
 * 
 * 对象晋升后, 将会在老生代空间中作为存活周期较长的对象来对待,接受新的回收算法处理
 *   
 */


/**
 * 3. Mark-Sweep & Mark-Compact
 * 对于老生代中的对象, 由于存活对象占较大比重, 再采用Scavenge的方式会有两个问题: 
 * 一个是存活对象较多, 复制存活对象的效率将会降低; 另一个问题依然是浪费一半空间的问题. 
 * 这两个问题导致应该声明周期较长的对象时 Scavenge 会显得捉襟见肘. 为此, V8在老生代
 * 中主要采用了 Mark-Sweep  和  Mark-Compact 相结合的方式进行垃圾回收.
 * 
 * Mark-Sweep 是标记清除的意思, 它分为标记和清除两个阶段. 与 Scavenge 相比, Mark-Sweep
 * 并不将内存空间划分为两半, 所以不存在浪费一半空间的行为. 与Scavenge 复制活着的对象不同,
 * Mark-Sweap 在标记阶段遍历堆中的所有对象, 并标记活着的对象, 在随后的清除阶段中, 只清除没有
 * 被标记的对象. 可以看出, Scavenge中只复制活着的对象,而Mark-Sweep只清理死亡对象. 活对象
 * 在新生代中只占较小部分, 死对象在老生代中只占较小部分, 这是两种回收方式能高效处理的原因.
 * 
 * Mark-Sweep最大的问题是在进行一次标记清除回收后, 内存空间会出现不连续的状态. 这种内存碎片
 * 会对后续的内存分配造成问题, 因为很可能出现需要分配一个大对象的情况, 这时所有的碎片空间都无法
 * 完成此次分配, 就会提前触发垃圾回收,而这次回收是不必要的
 * 
 * 为了解决Mark-Sweep的内存碎片问题, Mark-Compact 被提出来. Mark-Compact 是标记整理的意思,
 * 是在 Mark-Sweep 的基础上演变而来的, 它们的差别在于对象在标记为死亡后,在整理的过程中, 将活着的
 * 对象往一端移动, 移动完成后, 直接清理掉边界外的内存. 
 * 
 * 在Mark-Sweep 和 Mark-Compact 之间, 由于Mark-Compact 需要移动对象, 所以它的执行速度不可能很快, 所以
 * 在取舍上, V8 主要使用 Mark-Sweep, 在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact.
 */


/**
 * 4. Incremental Marking
 * 为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况, 垃圾回收的3种基本算法都需要将应用逻辑
 * 暂停下来, 待执行完垃圾回收后再恢复执行应用逻辑, 这种行为被称为 "全停顿"(stop-the-world). 在V8的分代
 * 式垃圾回收中,  一次小垃圾回收只收集新生代,  由于新生代默认配置得较小, 且其中存活对象通常较少, 所以即便它
 * 是全停顿的影响也不大.  但V8 的老生代通常配置的较大, 且存活对象较多, 全堆垃圾回收(full 垃圾回收) 的标记,
 * 清理, 整理等动作造成的停顿就会比较可怕, 需要设法改善. 
 * 
 * 为了降低全堆垃圾回收带来的停顿时间, V8 先从标记阶段入手, 将原本要一口气停顿完成的动作改为增量标记
 * (incremental marking), 也就是拆分为许多小  "步进", 每做完一 "步进" 就让JavaScript 应用逻辑执行一小会儿,
 * 垃圾回收与应用咯及交替执行直到标记阶段完成.
 * 
 * 
 * JavaScript  |-->|           |     |    |    |    |            |     
 *             |   |           |---->|    |--->|    |            |--->
 * 垃圾回收      |   |- 初始化标->|     |--->|    |    |-->清理/整理->|
 *             |    | 标记(停顿) |     |    |    |   |             |
 *                                    增量标记
 * 
 * V8 在经过增量标记的改进后, 垃圾回收的最大停顿时间可以减少到原本的 1/6 左右.
 * 
 * V8 后续还引入了延迟清理 (lazy sweeping) 与增量式整理( incremental compaction), 让清理与整理动作
 * 也变成增量式的. 同时还计划引入并行标记与并行清理,进一步利用多核性能降低每次停顿的时间.
 */

/**
 * 5. 小结
 * 从V8的自动垃圾回收机制的设计角度可以看到, V8 对内存使用进行限制的缘由. 新生代设计为一个较小的内存空间是合理的,
 * 而老生代空间过大对于垃圾回收并无特别意义. V8 对内存限制的设置对于 Chrome 浏览器这种每个选项卡页面使用一个V8
 * 实例而言, 内存的使用是绰绰有余了. 对于Node编写的服务器端来说, 内存限制也并不影响正常场景下的使用. 但是对于V8
 * 的垃圾回收特点 和 JavaScript 在单线程上的执行情况, 垃圾回收是影响性能的因素之一. 想要高性能的执行效率, 需要
 * 注意让垃圾回收尽量少地进行,尤其是全堆垃圾回收.
 */