/**
 * JavaScript, V8, 事件驱动, 非阻塞 I/O 模型的设计.
 */

/**
 * 1. V8 的内存限制
 * 在Node中通过JavaScript使用内存时就会发现只能使用部分内存 [64位系统下约为1.4GB, 32位系统下约为0.7GB]. 
 * 在这样的限制下,将会导致Node无法直接操作大内存对象, 比如无法将一个 2GB 的文件读入内存中进行字符串分析处理,即使
 * 物理内存有32GB. 这样在单个Node进程的情况下, 计算机的内存资源无法得到充足的作用.
 * 
 * 造成这个问题的主要原因在于Node基于V8构建, 所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行
 * 分配和管理的. V8的这套内存管理在浏览器的应用场景下使用起来绰绰有余,足以胜任前端页面中的所有需求. 但在Node中,
 * 这却限制了开发者随心所欲使用大内存的想法.
 * 
 * 尽管在服务器端操作大内存也不是常见的需求场景, 但有了限制之后, 我们的行为就如同带着 镣铐跳舞, 如果在实际的应用中
 * 不小心触碰到这个限制,会造成进程退出. 要知晓V8为何限制了内存的用量, 则需要回归到V8在内存使用上的策略. 知晓其原理
 * 后, 才能避免问题并更好地进行内存管理.
 */

/**
 * 2. V8的对象分配
 * 在V8中, 所有的JavaScript对象都是通过堆来进行分配的. Node提供了V8中内存使用量的查看方式, 执行下面的代码,将得到
 * 输出的内存信息:
 * > node
 * > process.memoryUsage()
 * {
 *   rss: 19853312,
 *   heapTotal: 4608000,
 *   heapUsed: 2427648,
 *   external: 1374424
 *  }
 * 在上述代码中, 在 memoryUsage()方法返回的 3个属性中, heapTotal 和 heapUsed 是 V8 的堆内存使用情况,前者是已申请
 * 到堆内存,后者是当前使用的量. 至于 res 为何, 我们在后续的内容中会介绍到.
 * 
 * 当我们在代码中声明变量并赋值时, 所使用对象的内存就分配在堆中. 如果已申请的堆空闲内存不够分配新的对象, 将继续申请堆内存,
 * 直到堆的大小超过 V8 的限制为止.
 * 
 * 至于V8为何要限制堆的大小, 表层原因为V8最初为浏览器而设计, 不太可能遇到用大量内存的场景. 对于网页来说, V8的限制值已经绰绰有余.
 * 深层原因的V8的垃圾回收机制的限制. 按官方的说法, 以1.5GB 的垃圾回收内存为例, V8 做一次小的垃圾回收需要50毫秒以上, 做一次非增量
 * 式的垃圾回收甚至要1秒以上. 这是垃圾回收中引起JavaScript线程暂停执行的时间, 在这样的情况不仅仅后端服务无法接受,前端浏览器也无法
 * 接受. 因此, 在当时的考虑下直接限制堆内存是一个好的选择.
 * 
 * 当然, 这个限制也不是不能打开, V8依然提供了选项让我们使用更多的内存. Node 在启动时可以传递
 * --max-old-space-size 或 --max-new-space-size 来调整内存限制的大小,如下:
 * > node --max-old-space-size=1700 test.js //单位为MB
 * //或者
 * > node --max-new-space-size=1024 test.js //单位为KB
 * 
 */