/**
 * 1. 作用域
 * 
 * 提到如何触发垃圾回收, 第一个要介绍的是  作用域(scope). 在 JavaScript中能形成作用域的有
 * -> 函数调用, with 以及 全局作用域.
 * 
 * 如下代码: 
 * var foo = function() {
 *    var local = {};
 * };
 * 
 * foo()函数在每次被调用时会创建对应的作用域, 函数执行结束后, 该作用域将会销毁. 同时作用域中声明的
 * 局部变量分配在该作用域上, 随作用域的销毁而销毁. 只被局部变量引用的对象存活周期较短. 在这个示例中,
 * 由于对象非常小, 将会分配在新生代中的From空间中, 在作用域释放后, 局部变量 local 失效, 其引用的对象
 * 将会在下次垃圾回收时被释放.
 * 
 * 以上就是最基本的内存回收过程
 */


/**
 * i. 标识符查找
 * 
 * 与作用域相关的即是标识符查找. 所谓标识符, 可以理解为 变量名. 在下面的代码中, 执行 bar() 函数时,将会
 * 遇到 local 变量: 
 * 
 * var bar = function() {
 *    console.log(local);
 * };
 * 
 * JavaScript 在执行时会去查找该变量定义在哪里. 它最先查找的是当前作用域, 如果在当前作用域中无法找到该
 * 变量的声明, 将会向上级的作用域里查找, 直到查到为止. 
 */

/**
 * ii. 作用域链
 * 在下面的代码中: 
 */

/**
 * iii. 变量的主动释放
 * 如果变量的全局变量(不通过 var 声明 或 定义在 global 变量上), 由于全局作用域需要直到进程退出才能释放, 此时
 * 需要释放常驻内存的对象, 可以通过 delete 操作来删除引用关系. 或者将变量重新赋值, 让旧的对象脱离引用关系.在
 * 接下来的老生代内存清除和整理的过程中, 会被回收释放. 如下: 
 * 
 * global.foo = "I am global object";
 * console.log(global.foo); // -> "I am global object"
 * delete global.foo;
 * // 或者重新赋值
 * global.foo = undefined; // or null
 * console.log(global.foo); // -> undefined
 * 
 * 同样,如果在非全局作用域中, 想主动释放变量引用的对象, 也可以通过这样的方式. 虽然 delete 操作和重新赋值具有相同
 * 的效果, 但是在 V8 中通过 delete 删除对象的属性有可能干扰 V8 的优化, 所以通过赋值方式解除引用更好.
 */