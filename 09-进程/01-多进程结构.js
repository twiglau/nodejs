/**
 * Node提供了 child_process 模块, 并且也提供了 child_process.fork() 函数供我们实现
 * 进程的复制.
 * 
 * worker.js 启动它, 将会侦听1000到2000之间的一个随机端口.
 * master.js 将会根据当前机器上的CPU数量复制出对应Node进程数. 在*nix 系统下可以通过
 * ps aux  | grep worker.js
 * 
 * twiglau          80682   0.0  0.0  4268408    696 s001  R+   12:03下午   0:00.00 grep worker.js
 * twiglau          80629   0.0  0.2  4516668  17092 s002  S+   12:02下午   0:00.10 node worker.js
 * 
 * 以上就是著名的Master-Worker模式, 又称主从模式. 进程分为两种: 主进程和工作进程. 这是典型的分布式架构中用于并行
 * 处理业务的模式, 具备较好的可伸缩性和稳定性 主进程不负责具体的业务处理, 而是负责调度或管理工作进程,它是趋向与稳定的.
 * 工作进程负责具体的业务处理,因为业务的多种多样,甚至一项业务由多人开发完成,所以工作进程的稳定性值得开发者关注.
 * 
 * master.js -------------->| 主进程  |
 *                          |--------|
 *                         /             \
 * worker.js --------> | 工作 |         | 工作 |
 *                     | 进程 |         | 进程 |
 * 
 * 通过fork()复制的进程都是一个独立的进程, 这个进程中有着独立而全新的 V8 实例. 它需要至少 30 毫秒的启动时间和至少10
 * MB的内存. 尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上, 但是依然要切记fork()是昂贵的. 好在Node通过
 * 时间驱动的方式在单线程上解决了 大并发 的问题, 这里启动多个进程只是为了充分将 CPU 资源利用起来,而不是为了解决并发问题.
 */