/**
 * 搭建好了集群,充分利用了多核 CPU 资源, 似乎就可以迎接客户端大量的请求了.
 * 但请等等, 我们还有一些细节需要考虑.
 * > 性能问题.
 * > 多个工作进程的存活状态管理.
 * > 工作进程的平滑重启.
 * > 配置或者静态数据的动态重新载入.
 * > 其他细节
 * 
 * 是的, 虽然我们创建了很多工作进程, 但每个工作进程依然是在单线程上执行的,它的稳定性
 * 还不能得到完全的保障. 我们需要建立起一个健全的机制来保障Node应用的健壮性.
 * 
 * 1. 进程事件
 * 再次回归到子进程对象上, 除了引入关注的 send() 方法和 message 事件外, 子进程还有些
 * 什么呢? 首先除了 message 事件外, Node 还有如下这些事件.
 * 
 * > error: 当子进程无法被复制创建, 无法被杀死, 无法发送消息时会触发该事件.
 * 
 * > exit: 子进程退出时触发该事件, 子进程如果是正常退出, 这个事件的第一个参数为退出码,否则为null.
 * 如果进程是通过kill()方法被杀死的, 会得到第二个参数, 它表示杀死进程时的信号.
 * 
 * > close: 在子进程的标准输入输出流中止时触发该事件,参数与exit相同.
 * 
 * > disconnect: 在父进程或子进程中调用 disconnect() 方法时触发该事件, 在调用该方法时将关闭监听
 * IPC通道.
 * 
 * 上述这些事件是父进程能监听到的与子进程相关的事件. 除了 send() 外, 还能通过 kill() 方法给子进程
 * 发送消息. kill() 方法并不能真正地将通过IPC 相连的子进程杀死, 它只是给子进程发送了一个系统信号.
 * 默认情况下, 父进程将通过 kill() 方法给子进程发送一个 SIGTERM 信号. 它与进程默认的 kill() 方法
 * 类似,如下
 * 
 * //子进程
 * child.kill([signal]);
 * //当前进程
 * process.kill(pid, [signal]);
 * 
 * 它们一个发给子进程, 一个发给目标进程. 在POSIX标准中, 有一套完备的信号系统,在命令行中执行 kill -l
 * 可以看到详细的信号列表,如下
 * > kill -l
 * 
 * Node 提供了这些信号对应的信号事件, 每个进程都可以监听这些信号事件. 这些信号事件是用来通知进程的,每个
 * 信号事件有不同的含义, 进程在收到响应信号时, 应当做出约定的行为,如 SIGTERM 的软件中止信号,进程收到
 * 该信号时应当退出.如下
 * process.on('SIGTERM', function(){
 *     console.log('Got a SIGTERM, exiting...');
 *     process.exit(1);
 * });
 * 
 * console.log('server running with PID:', process.pid);
 * process.kill(process.pid, 'SIGTERM');
 */

/**
 * 2. 自动重启
 * 有了父子进程之间的相关事件之后, 就可以在这些关系之间创建出需要的机制了. 至少我们能够通过
 * 监听子进程的exit事件来获知其退出的信息, 接着前文的多进程架构, 我们在主进程上要加入一些子
 * 进程管理的机制, 比如重新启动一个工作进程来继续服务.如下
 * 
 *                 | 主进程 |
 *          /     |    \     \     \
 *      重新复制   退出   \     \     \
 *        /        \     \     \     \
 *   | 工作 | <- | 工作 | 工作 | 工作 | 工作 |
 *   | 进程 |    | 进程 | 进程 | 进程 | 进程 |
 * 
 * 主进程加入子进程管理机制, 如下
 * // master.js
 * var fork = require('child_process').fork;
 * var cpus = require('os').cpus();
 * 
 * var server = require('net').createServer();
 * server.listen(1337);
 */