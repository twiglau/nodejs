/**
 * HTTP服务器也抽象了一些事件,以供应用层使用,服务器也是一个 EventEmitter实例.
 * > connection事件: 在开始HTTP请求和响应前, 客户端与服务器需要建立底层的TCP连接, 这个连接可能因为
 * 开启了 keep-alive, 可以在多次请求响应之间使用; 当这个连接建立时, 服务器触发一次 connection事件.
 * 
 * > request事件: 建立TCP连接后, http模块底层将在数据流中抽象出 HTTP请求和 HTTP响应, 当请求数据发送
 * 到服务器端, 在解析出 HTTP 请求头后, 将会触发该事件; 在 res.end()后, TCP连接可能将用于下一次请求响应.
 * 
 * > close事件: 与 TCP 服务器的行为一致, 调用 server.close() 方法停止接受新的连接, 当已有的连接都断开
 * 时, 触发该事件; 可以给 server.close() 传递一个回调函数来快递来快速注册该事件.
 * 
 * > checkContinue事件: 某些客户端在发送较大的数据时, 并不会将数据直接发送,而是先发送一个头部带 Expect: 
 * 100-continue 的请求到服务器, 服务器将会触发 checkContinue 事件; 如果没有为服务器监听这个事件,服务器
 * 将会自动响应客户端 100 Continue 的状态码, 表示接受数据上床; 如果不接受数据的较多时, 响应客户端 400 Bad
 * Request 拒绝客户端继续发送数据即可. 需要注意的是, 当该事件发生时不会触发 request 事件, 两个事件之间互斥,
 * 当客户端收到 100 Continue 后重新发起请求时, 才会触发 request 事件. 
 * 
 * > connect事件: 当客户端发起CONNECT请求时触发, 而发起CONNECT请求通常在 HTTP 代理时出现; 如果不监听该
 * 事件, 发起该请求的连接将会关闭. 
 * 
 * > upgrade事件: 当客户端要求升级连接的协议时, 需要和服务器端协商, 客户端会在请求头中带上 Upgrade字段, 服务
 * 器端会在接收到这样的请求时触发该事件. 这在后文的 WebSocket 部分有详细流程的介绍.
 * 
 * > clientError事件: 连接的客户端触发 error 事件时, 这个错误会传递到服务器端,此时触发该事件. 
 */

/**
 * HTTP 客户端
 * 在对服务端的实现进行了描述后, HTTP 客户端的原理几乎不用再描述,因为它就是服务器端服务模型的另一部分,处于 HTTP的
 * 另一端,在整个报文的参与中, 报文头和报文体由它产生.
 * http 模块提供了一个底层 API: 
 * http.request(options,connect), 用于构造 HTTP 客户端.
 * 
 * 下面的示例 与 上文的 curl 命令大致相同: 
 * > curl -v http://127.0.0.1:1337
 * 
 * client01.js
 */

/**
 * 其中 options 参数决定了 这个HTTP请求头中的内容, 它的选项有如下这些: 
 * > host: 服务器的域名或IP地址, 默认为localhost.
 * > hostname: 服务器名称.
 * > port: 服务器端口, 默认为80
 * > localAddress: 建立网络连接的本地网卡.
 * > socketPath: Domain套接字路径
 * > method: HTTP请求方法, 默认为GET
 * > path: 请求路径,默认为 /.
 * > headers: 请求头对象.
 * > auth: Basic 认证, 这个值将被计算成请求头中的 Authorization 部分.
 * 
 * 报文体的内容由请求对象的 write() 和 end() 方法实现: 通过write() 方法向连接中写入数据,
 * 通过 end()方法告知报文结束. 它与浏览器中的 Ajax 调用及近相同, Ajax的实质就是一个异步的网络
 * HTTP请求.
 */

/**
 * 1. HTTP 响应
 * HTTP客户端的响应对象与服务器端较为类似, 在 ClientRequest 对象中, 它的事件叫做 response. ClientRequest
 * 在解析响应报文时, 一解析完响应头就触发 response 事件, 同时传递一个响应对象以供操作 clientResponse. 后续响应
 * 报文体以只读的方式提供.如下
 */

/**
 * 2. HTTP 代理
 * 如同服务器的实现一般, http 提供的 ClientRequest 对象也是基于TCP层实现的,在keepalive的情况下,一个底层会话连接
 * 可以多次用于请求. 为了重用 TCP 连接, http模块包含一个默认的客户端代理对象 http.globalAgent. 它对每个服务器端
 * ( host + post ) 创建的连接进行了管理, 默认情况下, 通过 ClientRequest 对象同一个服务器端发起的 HTTP 请求最多
 * 可以创建 5 个连接. 它的实质是一个连接池,如下
 * 
 *          \ 请求   \
 *      |-------Y------------------------------|
 *      |      /   \                           |
 *      |  \ 有空闲连接? |---- 否 ---> |加入等待|  |
 *      |        Y                       Y     |
 *      |        是                      |      |
 *      |        |                       Y     |
 *  代理 |  | 发起请求   |<---- 是 --- | 是否有 |  |
 *      |        |                  |等待请求?|  |
 *      |        Y                      ^       |
 *      |        |                      |       |
 *      |  | 结束请求   |---------->  |归还连接 |  |
 *      |        |                              |
 *      |--------Y------------------------------|
 *          |   结束   |
 *          |---------| 
 * HTTP 代理对服务器端创建的连接进行管理
 * 
 * 调用 HTTP 客户端同时对一个服务端发起 10 次 HTTP 请求时, 其实质只有 5 个请求处于并发状态,
 * 后续的请求需要等待某个请求完成服务后才真正发出. 这与浏览器对同一个域名有下载连接数的限制是相同
 * 的行为.
 * 
 * 如果你在服务器通过 ClientRequest 调用网络中的其他 HTTP服务, 记得关注代理对象对网络请求的限制. 
 * 一旦请求量过大, 连接限制将会限制服务性能. 如需要改变, 可以在 options 中传递 agent 选项. 默认
 * 情况下, 请求会采用全局的代理对象, 默认连接数限制的为 5.
 * 
 */